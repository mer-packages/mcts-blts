/* check_crypto.c -- Test vectors for crypto stuff

   Copyright (C) 2000-2010, Nokia Corporation.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, version 2.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/* gcc -o check_crypto check_crypto.c wlan-core-crypto.c -lbltscommon */

#include "wlan-core-crypto.h"


int check_vector(const u8 *vec, const u8 *cmp, size_t len)
{
	unsigned i;
	for(i = 0; i < len; ++i)
		if(vec[i] != cmp[i]) {
			printf("compare mismatch at %d - %02x != %02x\n",i,vec[i],cmp[i]);
			return -1;
		}
	return 0;
}

int check_prf()
{
	u8 key[20] = {
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa
	};
	size_t key_len = 20;
	char *label = "prefix";
	u8 data[50] = {
		0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
		0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
		0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
		0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
		0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd,
	};
	size_t data_len = 50;
	u8 prf[64];
	size_t prf_len = 64;
	u8 cmp[64] = {
		0xe1, 0xac, 0x54, 0x6e, 0xc4, 0xcb, 0x63, 0x6f,
		0x99, 0x76, 0x48, 0x7b, 0xe5, 0xc8, 0x6b, 0xe1,
		0x7a, 0x02, 0x52, 0xca, 0x5d, 0x8d, 0x8d, 0xf1,
		0x2c, 0xfb, 0x04, 0x73, 0x52, 0x52, 0x49, 0xce,
		0x9d, 0xd8, 0xd1, 0x77, 0xea, 0xd7, 0x10, 0xbc,
		0x9b, 0x59, 0x05, 0x47, 0x23, 0x91, 0x07, 0xae,
		0xf7, 0xb4, 0xab, 0xd4, 0x3d, 0x87, 0xf0, 0xa6,
		0x8f, 0x1c, 0xbd, 0x9e, 0x2b, 0x6f, 0x76, 0x07
	};

	if(sha1_prf(key, key_len, label, data, data_len, prf, prf_len)) {
		printf("fault in sha1_prf\n");
		return -1;
	}

	return check_vector(prf, cmp, prf_len);
}

int check_psk()
{
	char *ssid = "BLTS-WPA2";
	char *passphrase = "abcdefgh";

	u8 psk[32];
	u8 cmp[32] = {
		0xc5, 0x63, 0xb5, 0x95, 0x94, 0x17, 0x1b, 0xd0,
		0x8a, 0xb1, 0xb5, 0x0c, 0x83, 0x31, 0x47, 0x1b,
		0x9a, 0x67, 0x2e, 0x3b, 0x84, 0x3f, 0x76, 0x67,
		0xf3, 0xd2, 0xa2, 0x28, 0xf8, 0x13, 0x57, 0x5c
	};

	if(wpa_derive_ccmp_pmk(passphrase, ssid, psk)) {
		printf("fault in wpa_derive_ccmp_pmk()\n");
		return -1;
	}
	return check_vector(psk, cmp, 32);
}

int check_ptk()
{
	u8 pmk[PMK_LEN] = {
		0xc5, 0x63, 0xb5, 0x95, 0x94, 0x17, 0x1b, 0xd0,
		0x8a, 0xb1, 0xb5, 0x0c, 0x83, 0x31, 0x47, 0x1b,
		0x9a, 0x67, 0x2e, 0x3b, 0x84, 0x3f, 0x76, 0x67,
		0xf3, 0xd2, 0xa2, 0x28, 0xf8, 0x13, 0x57, 0x5c
	};
	u8 aa[ETH_ALEN] = { 0x02, 0x00, 0x00, 0x00, 0x01, 0x00 };
	u8 spa[ETH_ALEN] = { 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 };
	u8 snonce[WPA_NONCE_LEN] = {
		0xa2, 0x69, 0xf8, 0x2e, 0xe2, 0x08, 0x0e, 0x41,
		0x73, 0xc5, 0xd0, 0xfd, 0x90, 0x16, 0xc7, 0x6b,
		0x19, 0x78, 0x48, 0x48, 0x06, 0x21, 0x8a, 0xe6,
		0xbd, 0x52, 0x13, 0x80, 0xb8, 0x87, 0xdf, 0x56
	};
	u8 anonce[WPA_NONCE_LEN] = {
		0x57, 0x20, 0xdd, 0x0f, 0x1d, 0xfc, 0x89, 0x82,
		0x76, 0xd4, 0x6f, 0xf2, 0x0d, 0x8e, 0xec, 0xf8,
		0x5e, 0x4b, 0x13, 0x3e, 0x11, 0x23, 0x24, 0x57,
		0x04, 0x36, 0x84, 0x9b, 0xc7, 0x2b, 0x7f, 0x6a
	};
	u8 ptk[48];
	u8 cmp[48] = {
		0x22, 0x86, 0xda, 0x8d, 0xb3, 0xac, 0x15, 0x11,
		0xa2, 0x36, 0x73, 0x9d, 0x9a, 0x10, 0xc9, 0xfb,
		0x63, 0x4c, 0xcb, 0x0a, 0x97, 0xc2, 0xfc, 0x90,
		0xf2, 0x32, 0xf8, 0x17, 0x0d, 0x58, 0x91, 0x55,
		0xd5, 0x6f, 0xed, 0x3a, 0x48, 0xf9, 0xc4, 0x99,
		0x57, 0xf9, 0xbe, 0xe2, 0xd8, 0xad, 0xe4, 0x96
	};
	wpa_pmk_to_ptk(pmk, 32, "Pairwise key expansion",
		aa, spa, anonce, snonce, ptk, 48);

	return check_vector(ptk, cmp, 48);
}

int check_nonce()
{
	int i,ret = 0;
	u8 nonce[WPA_NONCE_LEN];
	u8 addr[ETH_ALEN] = { 0,0,0,0,0,0 };
	for(i = 0; i < 4; ++i) {
		if(i)
			sleep(1);
		if(rsna_nonce_generator(addr, nonce)) {
			printf("nonce generation failure\n");
			ret = -1;
			continue;
		}
		int j;
		for(j = 0; j < WPA_NONCE_LEN; ++j)
			printf(" %02x", nonce[j]);
		printf("\n");
	}
	return ret;
}

int check_aes_unwrap()
{
	u8 buf[16] = {};
	u8 kek[] = {
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
		0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
	};
	u8 plain[] = {
		0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
		0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
	};
	u8 crypt[] = {
		0x1F, 0xA6, 0x8B, 0x0A, 0x81, 0x12, 0xB4, 0x47,
		0xAE, 0xF3, 0x4B, 0xD8, 0xFB, 0x5A, 0x7B, 0x82,
		0x9D, 0x3E, 0x86, 0x23, 0x71, 0xD2, 0xCF, 0xE5
	};
	if(aes_unwrap(kek, 2, crypt, buf)) {
		printf("fault in aes_unwrap()\n");
		return -1;
	}
	return check_vector(buf, plain, 16);
}

int main()
{
	printf("PRF test vector: ");
	if(!check_prf())
		printf("ok\n");
	printf("PSK derivation: ");
	if(!check_psk())
		printf("ok\n");
	printf("PMK to PTK (WPA-PSK/CCMP): ");
	if(!check_ptk())
		printf("ok\n");
	/* printf("Generating 4 nonces, should be all different: \n"); */
	/* if(!check_nonce()) */
	/* 	printf("\tok\n"); */
	/* else */
	/* 	printf("\tfailed\n"); */

	printf("AES unwrap: ");
	if(!check_aes_unwrap())
		printf("ok\n");

	return 0;
}

