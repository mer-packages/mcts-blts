
	MWTS-COMMON
	-----------


INTRODUCTION

  Mwts-common is a Qt based framework library used by all MWTS test assets.
  Creating common library lowers the need for rewritten code and ease up
  maintenance. Library consists of small test framework and base class
  MwtsTest for test modules. Main idea is that module developers only needs
  to include <MwtsCommon> and derive own test class from MwtsTest class.
  Aim is to handle as many things as possible in background. The interface
  is designed to be very simple and easy to use to make learning curve almost
  nonexistent.

 
SOURCE CODE AND COMPILING

  mwts-common compiles on typical debian/linux distributions by executing

          dpkg-buildpackage -rfakeroot

  if you have missing dependencies, add them with

          apt-get install <package>

  on non-debian linux system you can compile and install by (no dependency check)

          qmake
          make
          make install (as root)

  Doxygen API documentation can be generated by running 'doxygen' in mwts-common
  root directory
  

FEATURES

  - Logging
  - Standard result output for all test assets
  - Configuration file reading from /usr/lib/tests/MyTest.cfg
  - Support for iterative testing
  - Result calculations
     * Median
     * Mean
     * Minimum
     * Maximum
     * Standard deviation
  - System load generation during tests
     * Cpu load
     * Memory load
  - Changing Radio Access Technology between GSM, UMTS and DUAL modes
  - System resource measurements during testing
     * System memory usage
     * Overall CPU usage
     * Realtime CPU/memory meters on remote host
  - Qt UI base


RESULT OUTPUT

  mwts-common automatically creates following files during testing.
  /var/log/tests/
      <case_name>.log       <-- log output (and debug if enabled)
      <case_name>.result    <-- result file
      <case_name>.report    <-- xml report generated from result, if iterative and limts set
      <case_name>.monitor   <-- realtime cpu and memory monitor output
  /home/user/MyDocs/<case_name>
      various files generated by endurance gathering tools, when enabled. See *environment* section


C++ INTERFACE

  Include:
    #include <MwtsCommon>

  Logging: 
      qDebug() << "Use this kind of logging for debug messages";
      qWarning() << "In case of some very light misbehaviour, use this";
      qCritical() << "In case of any kind of error, use this. It will \
         cause cases to fail automatically";

  Results:
      // use this for measurement
      g_pResult->AddMeasure("ReadThroughput", throughput, "MB/s");
      // I want to show that this part of code was passed or not
      g_pResult->StepPassed("FileRead", true); 
      g_pResult->Write("This is very important text for tester to understand scores");

  Declaring test module:
      class FilesystemTest : public MwtsTest
      {
      public:
           void OnInitialize()   // called during initialization
           void OnUninitialize()   // called during uninitialization
      };
  
  Inside test module code:
      Start(); // starts the QApplication main loop and returns when
               // timeout occurs or stopped with Stop()
      Stop();  // stops the mainloop. to be used in signal handler slots
    
  That's all you should need in typical cases. 

  
MIN SCRIPTER INTERFACE

  All these functions are usable with all test modules derived from MwtsTest.
  Also you need to call MwtsMin::DeclareFunctions() in your ts_get_test_cases() function

    Init 
      * initializes the test module and calls test modules OnInizialize method
    Close
      * uninitializes the test module and calls test modules OnUninitialize method
    SetFailTimeout
      * set a fail timeout for test in milliseconds
    SetTestTimeout
      * set timeout for test where we run for example video for some amount of time
    StartIteration
      * to be called as first thing in every iteration
    EndIteration
      * to be called as last thing in every iteration
    StartCpuLoad <percentage>
      * starts artificial CPU load. percentage for example 90
    StopCpuLoad
      * stops the CPU load
    StartMemLoad <amount_MB>
      * reserves given amount of memory from the system
    StopMemLoad
      * frees previously reserved memory
    EnableUI
      * Enables UI usage with module. Must be called before Init!!
    SetLimits <target> <fail_limit>
      * Sets NFT case target and failure limit


ENVIRONMENT

  You can use environment variables to change behaviour of the library

          export MWTS_DEBUG=1       <-- enables debugging in logs
          export MWTS_LOG_PRINT=1   <-- outputs logs directly to console. not very nice with MIN cui.
          export MWTS_ENDURANCE=3   <-- collects endurance data every 3rd iteration


KNOWN ISSUES

  Doxygen documentation misses MIN interface functions
 

